{"componentChunkName":"component---node-modules-gatsby-theme-academic-src-templates-post-post-jsx","path":"/research/constant_time/","result":{"data":{"mdx":{"timeToRead":1,"tableOfContents":{"items":[{"url":"#introduction","title":"Introduction"},{"url":"#ongoing-work","title":"Ongoing Work"}]},"frontmatter":{"cover":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/4dc83b10f42ad6f281c691a09366ba34/ad8ac/preview.png","srcSet":"/static/4dc83b10f42ad6f281c691a09366ba34/fd23e/preview.png 750w,\n/static/4dc83b10f42ad6f281c691a09366ba34/ad8ac/preview.png 1000w,\n/static/4dc83b10f42ad6f281c691a09366ba34/009b7/preview.png 1080w,\n/static/4dc83b10f42ad6f281c691a09366ba34/ba7d2/preview.png 1200w","sizes":"(min-width: 1000px) 1000px, 100vw"},"sources":[{"srcSet":"/static/4dc83b10f42ad6f281c691a09366ba34/cd166/preview.webp 750w,\n/static/4dc83b10f42ad6f281c691a09366ba34/37f42/preview.webp 1000w,\n/static/4dc83b10f42ad6f281c691a09366ba34/4dfd9/preview.webp 1080w,\n/static/4dc83b10f42ad6f281c691a09366ba34/e1548/preview.webp 1200w","type":"image/webp","sizes":"(min-width: 1000px) 1000px, 100vw"}]},"width":1000,"height":1000}}},"title":"Constant-Time Analysis for Well-Known Cryptography Libraries","date":"Apr 2020 - Present","tags":["Security & Privacy","Programming Language","Cryptography"],"path":"research/constant_time","excerpt":"This project presents a toolset for assessing whether a cryptographic function is constant-time on two given (distinct)input sets. The toolset extends new support to languages other than C or C++, including Python3, Golang, and JavaScript. We present a comprehensive test suite covering common cryptographic primitives and providing finely-chosen inputs that can cause non-constant-time behavior of certain implementations. We then evaluate our approach by applying this test suite to a set of libraries with our toolset and observing the violations that are detected. Our preliminary results suggest that language runtime features such as JIT may break the constant-time requirement.","links":[{"name":"draft(pdf)","url":null}],"commit":0,"type":"research"},"fileAbsolutePath":"/home/runner/work/Reapor-Yurnero.github.io/Reapor-Yurnero.github.io/content/research/constant_time/index.md","fields":{"slug":{"html":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"Constant-Time Analysis for Well-Known Cryptography Libraries\",\n  \"tags\": [\"Security & Privacy\", \"Programming Language\", \"Cryptography\"],\n  \"date\": \"Apr 2020 - Present\",\n  \"path\": \"research/constant_time\",\n  \"excerpt\": \"This project presents a toolset for assessing whether a cryptographic function is constant-time on two given (distinct)input sets. The toolset extends new support to languages other than C or C++, including Python3, Golang, and JavaScript. We present a comprehensive test suite covering common cryptographic primitives and providing finely-chosen inputs that can cause non-constant-time behavior of certain implementations. We then evaluate our approach by applying this test suite to a set of libraries with our toolset and observing the violations that are detected. Our preliminary results suggest that language runtime features such as JIT may break the constant-time requirement.\",\n  \"selected\": false,\n  \"cover\": \"./preview.png\",\n  \"links\": [{\n    \"name\": \"draft(pdf)\",\n    \"file\": \"./draft.pdf\"\n  }],\n  \"priority\": -6\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", {\n    \"id\": \"introduction\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1,\n    \"href\": \"#introduction\"\n  }, mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"icon icon-link\"\n  })), \"Introduction\"), mdx(\"p\", null, \"Timing attacks on cryptosystems have long been researched since 1996. Various attacks, such as cache timing attack on AES, and defenses, such as timing attack resistant AES-GCM, over widely used cryptography algorithms have been developed and applied to well-known libraries, such as OpenSSL. Tools have been developed for analyzing the time-constancy of a crypto-function implemented in C or C++. The time-constancy of cryptographic libraries implemented in other languages remains an understudied area. Consequently, applications and websites based on these libraries may suffer from potential security vulnerabilities. \"), mdx(\"p\", null, \"In this project, we aim to detect whether popular cryptographic libraries in Golang, JavaScript and Python 3 have constant-time implementations. Our contributions are: \"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"A constant-time assessment tool for Golang, JavaScriptand Python 3 evolved from \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/oreparaz/dudect\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow\"\n  }, \"dudect\"), \".\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"A test suite against common cryptography primitives.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Presentation and discussion of the results of evaluating the official Crypto library (and its extension) of Golang, PyCrypto, Cryptography, and PyCryptodome of Python3, and the official Cryptolibrary of Node.js\")), mdx(\"h2\", {\n    \"id\": \"ongoing-work\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1,\n    \"href\": \"#ongoing-work\"\n  }, mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"icon icon-link\"\n  })), \"Ongoing Work\"), mdx(\"p\", null, \"Future work will extend these preliminary investigations by\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"expanding the test vectors with more implementation-specific inputs\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"taking hardware optimization into consideration in measurements\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"delving into the impacts of runtime/JIT of Python and JS on constant-time implementations.\")));\n}\n;\nMDXContent.isMDXComponent = true;","htmlEncrypted":"","nonce":""}}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/Reapor-Yurnero.github.io/Reapor-Yurnero.github.io/content/research/constant_time/index.md","postPath":"research/constant_time","translations":[{"hreflang":"en","path":"/research/constant_time"}]}},"staticQueryHashes":["1552981879","2158328490","3013679938"],"slicesMap":{}}